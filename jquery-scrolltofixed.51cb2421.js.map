{"version":3,"sources":["js/jquery-scrolltofixed.js"],"names":["$","isScrollToFixed","el","data","ScrollToFixed","options","base","$el","isReset","position","originalPosition","originalOffsetTop","originalZIndex","target","offsetTop","offsetLeft","originalOffsetLeft","lastOffsetLeft","spacer","getLimit","limit","apply","isFixed","isAbsolute","isUnfixed","setFixed","css","outerWidth","outerHeight","cssOptions","zIndex","bottom","getMarginTop","dontSetWidth","width","addClass","baseClassName","className","setAbsolute","top","left","removeOffsets","setUnfixed","removeClass","setLeft","x","marginTop","checkScroll","wasReset","offset","trigger","offsets","window","scrollLeft","y","scrollTop","minWidth","postPosition","maxWidth","height","windowResize","event","is","windowScroll","requestAnimationFrame","init","extend","defaultOptions","after","bind","preFixed","postFixed","preUnfixed","postUnfixed","preAbsolute","postAbsolute","fixed","unfixed","spacerClass","ev","e","preventDefault","returnValue","unbind","remove","removeData","fn","scrollToFixed","each","jQuery"],"mappings":"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","file":"jquery-scrolltofixed.51cb2421.js","sourceRoot":"..","sourcesContent":["/*\n * ScrollToFixed\n * https://github.com/bigspotteddog/ScrollToFixed\n * \n * Copyright (c) 2011 Joseph Cava-Lynch\n * MIT license\n */\n(function($) {\n    $.isScrollToFixed = function(el) {\n        return !!$(el).data('ScrollToFixed');\n    };\n\n    $.ScrollToFixed = function(el, options) {\n        // To avoid scope issues, use 'base' instead of 'this' to reference this\n        // class from internal events and functions.\n        var base = this;\n\n        // Access to jQuery and DOM versions of element.\n        base.$el = $(el);\n        base.el = el;\n\n        // Add a reverse reference to the DOM object.\n        base.$el.data('ScrollToFixed', base);\n\n        // A flag so we know if the scroll has been reset.\n        var isReset = false;\n\n        // The element that was given to us to fix if scrolled above the top of\n        // the page.\n        var target = base.$el;\n\n        var position;\n        var originalPosition;\n        var originalOffsetTop;\n        var originalZIndex;\n\n        // The offset top of the element when resetScroll was called. This is\n        // used to determine if we have scrolled past the top of the element.\n        var offsetTop = 0;\n\n        // The offset left of the element when resetScroll was called. This is\n        // used to move the element left or right relative to the horizontal\n        // scroll.\n        var offsetLeft = 0;\n        var originalOffsetLeft = -1;\n\n        // This last offset used to move the element horizontally. This is used\n        // to determine if we need to move the element because we would not want\n        // to do that for no reason.\n        var lastOffsetLeft = -1;\n\n        // This is the element used to fill the void left by the target element\n        // when it goes fixed; otherwise, everything below it moves up the page.\n        var spacer = null;\n\n        var spacerClass;\n\n        var className;\n\n        // Capture the original offsets for the target element. This needs to be\n        // called whenever the page size changes or when the page is first\n        // scrolled. For some reason, calling this before the page is first\n        // scrolled causes the element to become fixed too late.\n        function resetScroll() {\n            // Set the element to it original positioning.\n            target.trigger('preUnfixed.ScrollToFixed');\n            setUnfixed();\n            target.trigger('unfixed.ScrollToFixed');\n\n            // Reset the last offset used to determine if the page has moved\n            // horizontally.\n            lastOffsetLeft = -1;\n\n            // Capture the offset top of the target element.\n            offsetTop = target.offset().top;\n\n            // Capture the offset left of the target element.\n            offsetLeft = target.offset().left;\n\n            // If the offsets option is on, alter the left offset.\n            if (base.options.offsets) {\n                offsetLeft += (target.offset().left - target.position().left);\n            }\n\n            if (originalOffsetLeft == -1) {\n                originalOffsetLeft = offsetLeft;\n            }\n\n            position = target.css('position');\n\n            // Set that this has been called at least once.\n            isReset = true;\n\n            if (base.options.bottom != -1) {\n                target.trigger('preFixed.ScrollToFixed');\n                setFixed();\n                target.trigger('fixed.ScrollToFixed');\n            }\n        }\n\n        function getLimit() {\n            var limit = base.options.limit;\n            if (!limit) return 0;\n\n            if (typeof(limit) === 'function') {\n                return limit.apply(target);\n            }\n            return limit;\n        }\n\n        // Returns whether the target element is fixed or not.\n        function isFixed() {\n            return position === 'fixed';\n        }\n\n        // Returns whether the target element is absolute or not.\n        function isAbsolute() {\n            return position === 'absolute';\n        }\n\n        function isUnfixed() {\n            return !(isFixed() || isAbsolute());\n        }\n\n        // Sets the target element to fixed. Also, sets the spacer to fill the\n        // void left by the target element.\n        function setFixed() {\n            // Only fix the target element and the spacer if we need to.\n            if (!isFixed()) {\n                // Set the spacer to fill the height and width of the target\n                // element, then display it.\n                spacer.css({\n                    'display' : target.css('display'),\n                    'width' : target.outerWidth(true),\n                    'height' : target.outerHeight(true),\n                    'float' : target.css('float')\n                });\n\n                // Set the target element to fixed and set its width so it does\n                // not fill the rest of the page horizontally. Also, set its top\n                // to the margin top specified in the options.\n\n                cssOptions={\n                    'z-index' : base.options.zIndex,\n                    'position' : 'fixed',\n                    'top' : base.options.bottom == -1?getMarginTop():'',\n                    'bottom' : base.options.bottom == -1?'':base.options.bottom,\n                    'margin-left' : '0px'\n                }\n                if (!base.options.dontSetWidth){ cssOptions['width']=target.width(); };\n\n                target.css(cssOptions);\n                \n                target.addClass(base.options.baseClassName);\n                \n                if (base.options.className) {\n                    target.addClass(base.options.className);\n                }\n\n                position = 'fixed';\n            }\n        }\n\n        function setAbsolute() {\n\n            var top = getLimit();\n            var left = offsetLeft;\n\n            if (base.options.removeOffsets) {\n                left = '';\n                top = top - offsetTop;\n            }\n\n            cssOptions={\n              'position' : 'absolute',\n              'top' : top,\n              'left' : left,\n              'margin-left' : '0px',\n              'bottom' : ''\n            }\n            if (!base.options.dontSetWidth){ cssOptions['width']=target.width(); };\n\n            target.css(cssOptions);\n\n            position = 'absolute';\n        }\n\n        // Sets the target element back to unfixed. Also, hides the spacer.\n        function setUnfixed() {\n            // Only unfix the target element and the spacer if we need to.\n            if (!isUnfixed()) {\n                lastOffsetLeft = -1;\n\n                // Hide the spacer now that the target element will fill the\n                // space.\n                spacer.css('display', 'none');\n\n                // Remove the style attributes that were added to the target.\n                // This will reverse the target back to the its original style.\n                target.css({\n                    'z-index' : originalZIndex,\n                    'width' : '',\n                    'position' : originalPosition,\n                    'left' : '',\n                    'top' : originalOffsetTop,\n                    'margin-left' : ''\n                });\n\n                target.removeClass('scroll-to-fixed-fixed');\n\n                if (base.options.className) {\n                    target.removeClass(base.options.className);\n                }\n\n                position = null;\n            }\n        }\n\n        // Moves the target element left or right relative to the horizontal\n        // scroll position.\n        function setLeft(x) {\n            // Only if the scroll is not what it was last time we did this.\n            if (x != lastOffsetLeft) {\n                // Move the target element horizontally relative to its original\n                // horizontal position.\n                target.css('left', offsetLeft - x);\n\n                // Hold the last horizontal position set.\n                lastOffsetLeft = x;\n            }\n        }\n\n        function getMarginTop() {\n            var marginTop = base.options.marginTop;\n            if (!marginTop) return 0;\n\n            if (typeof(marginTop) === 'function') {\n                return marginTop.apply(target);\n            }\n            return marginTop;\n        }\n\n        // Checks to see if we need to do something based on new scroll position\n        // of the page.\n        function checkScroll() {\n            if (!$.isScrollToFixed(target)) return;\n            var wasReset = isReset;\n\n            // If resetScroll has not yet been called, call it. This only\n            // happens once.\n            if (!isReset) {\n                resetScroll();\n            } else if (isUnfixed()) {\n                // if the offset has changed since the last scroll,\n                // we need to get it again.\n\n                // Capture the offset top of the target element.\n                offsetTop = target.offset().top;\n\n                // Capture the offset left of the target element.\n                offsetLeft = target.offset().left;\n            }\n\n            // Grab the current horizontal scroll position.\n            var x = $(window).scrollLeft();\n\n            // Grab the current vertical scroll position.\n            var y = $(window).scrollTop();\n\n            // Get the limit, if there is one.\n            var limit = getLimit();\n\n            // If the vertical scroll position, plus the optional margin, would\n            // put the target element at the specified limit, set the target\n            // element to absolute.\n            if (base.options.minWidth && $(window).width() < base.options.minWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.maxWidth && $(window).width() > base.options.maxWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.bottom == -1) {\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element at the specified limit, set the target\n                // element to absolute.\n                if (limit > 0 && y >= limit - getMarginTop()) {\n                    if (!isAbsolute() || !wasReset) {\n                        postPosition();\n                        target.trigger('preAbsolute.ScrollToFixed');\n                        setAbsolute();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element above the top of the page, set the target\n                // element to fixed.\n                } else if (y >= offsetTop - getMarginTop()) {\n                    if (!isFixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preFixed.ScrollToFixed');\n\n                        // Set the target element to fixed.\n                        setFixed();\n\n                        // Reset the last offset left because we just went fixed.\n                        lastOffsetLeft = -1;\n\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                    // If the page has been scrolled horizontally as well, move the\n                    // target element accordingly.\n                    setLeft(x);\n                } else {\n                    // Set the target element to unfixed, placing it where it was\n                    // before.\n                    if (!isUnfixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preUnfixed.ScrollToFixed');\n                        setUnfixed();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                }\n            } else {\n                if (limit > 0) {\n                    if (y + $(window).height() - target.outerHeight(true) >= limit - (getMarginTop() || -getBottom())) {\n                        if (isFixed()) {\n                            postPosition();\n                            target.trigger('preUnfixed.ScrollToFixed');\n\n                            if (originalPosition === 'absolute') {\n                                setAbsolute();\n                            } else {\n                                setUnfixed();\n                            }\n\n                            target.trigger('unfixed.ScrollToFixed');\n                        }\n                    } else {\n                        if (!isFixed()) {\n                            postPosition();\n                            target.trigger('preFixed.ScrollToFixed');\n                            setFixed();\n                        }\n                        setLeft(x);\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                } else {\n                    setLeft(x);\n                }\n            }\n        }\n\n        function getBottom() {\n            if (!base.options.bottom) return 0;\n            return base.options.bottom;\n        }\n\n        function postPosition() {\n            var position = target.css('position');\n\n            if (position == 'absolute') {\n                target.trigger('postAbsolute.ScrollToFixed');\n            } else if (position == 'fixed') {\n                target.trigger('postFixed.ScrollToFixed');\n            } else {\n                target.trigger('postUnfixed.ScrollToFixed');\n            }\n        }\n\n        var windowResize = function(event) {\n            // Check if the element is visible before updating it's position, which\n            // improves behavior with responsive designs where this element is hidden.\n            if(target.is(':visible')) {\n                isReset = false;\n                checkScroll();\n            }\n        }\n\n        var windowScroll = function(event) {\n            (!!window.requestAnimationFrame) ? requestAnimationFrame(checkScroll) : checkScroll();\n        }\n\n        // From: http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED\n        var isPositionFixedSupported = function() {\n            var container = document.body;\n\n            if (document.createElement && container && container.appendChild && container.removeChild) {\n                var el = document.createElement('div');\n\n                if (!el.getBoundingClientRect) return null;\n\n                el.innerHTML = 'x';\n                el.style.cssText = 'position:fixed;top:100px;';\n                container.appendChild(el);\n\n                var originalHeight = container.style.height,\n                originalScrollTop = container.scrollTop;\n\n                container.style.height = '3000px';\n                container.scrollTop = 500;\n\n                var elementTop = el.getBoundingClientRect().top;\n                container.style.height = originalHeight;\n\n                var isSupported = (elementTop === 100);\n                container.removeChild(el);\n                container.scrollTop = originalScrollTop;\n\n                return isSupported;\n            }\n\n            return null;\n        }\n\n        var preventDefault = function(e) {\n            e = e || window.event;\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n            e.returnValue = false;\n        }\n\n        // Initializes this plugin. Captures the options passed in, turns this\n        // off for devices that do not support fixed position, adds the spacer,\n        // and binds to the window scroll and resize events.\n        base.init = function() {\n            // Capture the options for this plugin.\n            base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);\n\n            originalZIndex = target.css('z-index')\n\n            // Turn off this functionality for devices that do not support it.\n            // if (!(base.options && base.options.dontCheckForPositionFixedSupport)) {\n            //     var fixedSupported = isPositionFixedSupported();\n            //     if (!fixedSupported) return;\n            // }\n\n            // Put the target element on top of everything that could be below\n            // it. This reduces flicker when the target element is transitioning\n            // to fixed.\n            base.$el.css('z-index', base.options.zIndex);\n\n            // Create a spacer element to fill the void left by the target\n            // element when it goes fixed.\n            spacer = $('<div />');\n\n            position = target.css('position');\n            originalPosition = target.css('position');\n\n            originalOffsetTop = target.css('top');\n\n            // Place the spacer right after the target element.\n            if (isUnfixed()) base.$el.after(spacer);\n\n            // Reset the target element offsets when the window is resized, then\n            // check to see if we need to fix or unfix the target element.\n            $(window).bind('resize.ScrollToFixed', windowResize);\n\n            // When the window scrolls, check to see if we need to fix or unfix\n            // the target element.\n            $(window).bind('scroll.ScrollToFixed', windowScroll);\n\n            // For touch devices, call checkScroll directlly rather than\n            // rAF wrapped windowScroll to animate the element\n            if ('ontouchmove' in window) {\n              $(window).bind('touchmove.ScrollToFixed', checkScroll);\n            }\n\n            if (base.options.preFixed) {\n                target.bind('preFixed.ScrollToFixed', base.options.preFixed);\n            }\n            if (base.options.postFixed) {\n                target.bind('postFixed.ScrollToFixed', base.options.postFixed);\n            }\n            if (base.options.preUnfixed) {\n                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);\n            }\n            if (base.options.postUnfixed) {\n                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);\n            }\n            if (base.options.preAbsolute) {\n                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);\n            }\n            if (base.options.postAbsolute) {\n                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);\n            }\n            if (base.options.fixed) {\n                target.bind('fixed.ScrollToFixed', base.options.fixed);\n            }\n            if (base.options.unfixed) {\n                target.bind('unfixed.ScrollToFixed', base.options.unfixed);\n            }\n\n            if (base.options.spacerClass) {\n                spacer.addClass(base.options.spacerClass);\n            }\n\n            target.bind('resize.ScrollToFixed', function() {\n                spacer.height(target.height());\n            });\n\n            target.bind('scroll.ScrollToFixed', function() {\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n                checkScroll();\n            });\n\n            target.bind('detach.ScrollToFixed', function(ev) {\n                preventDefault(ev);\n\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n\n                $(window).unbind('resize.ScrollToFixed', windowResize);\n                $(window).unbind('scroll.ScrollToFixed', windowScroll);\n\n                target.unbind('.ScrollToFixed');\n\n                //remove spacer from dom\n                spacer.remove();\n\n                base.$el.removeData('ScrollToFixed');\n            });\n\n            // Reset everything.\n            windowResize();\n        };\n\n        // Initialize the plugin.\n        base.init();\n    };\n\n    // Sets the option defaults.\n    $.ScrollToFixed.defaultOptions = {\n        marginTop : 0,\n        limit : 0,\n        bottom : -1,\n        zIndex : 1000,\n        baseClassName: 'scroll-to-fixed-fixed'\n    };\n\n    // Returns enhanced elements that will fix to the top of the page when the\n    // page is scrolled.\n    $.fn.scrollToFixed = function(options) {\n        return this.each(function() {\n            (new $.ScrollToFixed(this, options));\n        });\n    };\n})(jQuery);\n"]}